sorts = (
"""<b>Код на Python</b>
<code>
def bubble_sort(array):
    a = array
    for i in range(len(a),0,-1):
        for j in range(1, i):
            if a[j-1] > a[j]:
                tmp = a[j-1]
                a[j-1] = a[j]
                a[j] = tmp
                print a
    return a
</code>
""",
"""<b>Код на Python</b>
def insertion_sort(arrayToSort):
    a = arrayToSort
    for i in range(len(a)):
        v = a[i]
        j = i;
        while (a[j-1] > v) and (j > 0):
            a[j] = a[j-1]
            j = j - 1
        a[j] = v
        print a
    return a
""",
"""<b>Код на Python</b>
<code>
for i in range(len(arr)):
    for j in range(i, len(arr)):
        if(arr[i] > arr[j]):
            arr[i], arr[j] = arr[j], arr[i]

print arr
</code>
""",
"""<b>Код на Python</b>
<code>
def Shell(A):
    t = int(len(A)/2)
    while t > 0:
        for i in range(len(A)-t):
            j = i
            while j >= 0 and A[j] > A[j+t]:
                A[j], A[j+t] = A[j+t], A[j]
                j -= 1
        t = int(t/2)
</code>
""")

alg = (
"""<b>Код на Python</b>
<code>
def gcd(a,b):
    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a        
    print (a)
</code>
""",
"""<b>Код на Python</b>
<code>
def fac(n):
     if n == 0:
          return 1
     return fac(n-1) * n
</code>
""",
"""<b>Код на Python</b>
<code>
import bisect
 
N, M = input().split()
list1 = (int(input()) for _ in range(int(N)))
list2 = (int(input()) for _ in range(int(M)))
 
for x in list2:
    i = bisect.bisect_left(list1, x)
    if list1[i] == x:
        print(i + 1, bisect.bisect(list1, x, i))
    else:
        print(0)
</code>
""",
"""<b>Код на Python</b>
<code>
x = int(input("Введите натуральное число: "))
n = ""
 
while x > 0:
    y = str(x % 2)
    n = y + n
    x = int(x / 2)
 
print (n)
</code>
""",
"""<b>Код на Python</b>
<code>
def fib(n):
    if n==1 or n==2:
        return 1
    return fib(n-1) + fib(n-2)
</code>
"""
)

info = ("""
Сортировка простыми обменами, сортиро́вка пузырько́м Английский язык bubble sort) — простой алгоритм сортировки. Для понимания и реализации этот алгоритм — простейший, но эффективен он лишь для небольших массивов.


Алгоритм:
1) Последовательно бежим по массиву и сравниваем два соседних элемента, если порядок не верный то меняем их местами.

2) Повторять проходы на один меньше, чем кол-во элементов в массиве или пока не окажеться, что за проход не произведено ни одной замены.
""", 
"""Сортировка вставками (Insertion Sort) — это простой алгоритм сортировки. Суть его заключается в том что, на каждом шаге алгоритма мы берем один из элементов массива, находим позицию для вставки и вставляем. Стоит отметить что массив из 1-го элемента считается отсортированным.

Словесное описание алгоритма звучит довольно сложно, но на деле это самая простая в реализации сортировка. Каждый из нас, не зависимо от рода деятельности, применял алгоритм сортировки, просто не осознавал это:) Например когда сортировали купюры в кошельке — берем 100 рублей и смотрим — идут 10, 50 и 500 рублёвые купюры. Вот как раз между 50 и 500 и вставляем нашу сотню:) Или приведу пример из всех книжек — игра в карточного «Дурака». Когда мы тянем карту из колоды, смотрим на наши разложенные по возрастанию карты и в зависимости от достоинства вытянутой карты помещаем карту в соответствующее место. """,
"""
Просто и незатейливо — проходим по массиву в поисках максимального элемента. Найденный максимум меняем местами с последним элементом. Неотсортированная часть массива уменьшилась на один элемент (не включает последний элемент, куда мы переставили найденный максимум). К этой неотсортированной части применяем те же действия — находим максимум и ставим его на последнее место в неотсортированной части массива. И так продолжаем до тех пор, пока неотсортированная часть массива не уменьшится до одного элемента.
""",
"""
Сортировка Шелла — это надстройка над сортировкой вставками; вместо одного прохода мы делаем несколько, причем на i-ом проходе мы сортируем подмассивы из элементов, стоящих друг от друга на расстоянии d[i].

При этом на последнем проходе d[i] должно быть равно 1 (то есть последний шаг — это обычная сортировка вставками), это гарантирует корректность алгоритма.
""",
"""
Алгоритм Евклида – это алгоритм нахождения наибольшего общего делителя (НОД) пары целых чисел.
Наибольший общий делитель (НОД) – это число, которое делит без остатка два числа и делится само без остатка на любой другой делитель данных двух чисел. Проще говоря, это самое большое число, на которое можно без остатка разделить два числа, для которых ищется НОД.

Алгоритм нахождения НОД делением
Большее число делим на меньшее.
Если делится без остатка, то меньшее число и есть НОД (следует выйти из цикла).
Если есть остаток, то большее число заменяем на остаток от деления.
Переходим к пункту 1.
Пример:
Найти НОД для 30 и 18.
30/18 = 1 (остаток 12)
18/12 = 1 (остаток 6)
12/6 = 2 (остаток 0). Конец: НОД – это делитель. НОД (30, 18) = 6
""",
"""
Факториалом числа называют произведение всех натуральных чисел до него включительно. Например, факториал числа 5 равен произведению 1*2*3*4*5 = 120. Формулу нахождения факториала можно записать следующим образом: n! = 1 * 2 * … * n, где n – это число, а n! – факториал этого числа.
""",
"""
Двоичный (бинарный) поиск (также известен как метод деления пополам и дихотомия) — классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины. Используется в информатике, вычислительной математике и математическом программировании.

Частным случаем двоичного поиска является метод бисекции, который применяется для поиска корней заданной непрерывной функции на заданном отрезке.

Алгоритм:
1. Определение значения элемента в середине структуры данных. Полученное значение сравнивается с ключом.
2. Если ключ меньше значения середины, то поиск осуществляется в первой половине элементов, иначе — во второй.
3. Поиск сводится к тому, что вновь определяется значение серединного элемента в выбранной половине и сравнивается с ключом.
4. Процесс продолжается до тех пор, пока не будет найден элемент со значением ключа или не станет пустым интервал для поиска.
""",
"""
Алгоритм перевода целых чисел:

1. Последовательно выполнять деление данного числа и получаемых целых частных на основание новой системы счисления до тех пор, пока не получится частное, меньше делителя.
2. Полученные остатки, являющиеся цифрами числа в новой системе счисления, привести в соответствие с алфавитом новой системы счисления.
3. Составить число в новой системе счисления, записывая его, начиная с последнего остатка
""",
"""
v
"""
)